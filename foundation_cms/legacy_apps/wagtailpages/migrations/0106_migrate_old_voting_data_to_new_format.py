# Generated by Django 3.2.21 on 2023-10-04 11:28

from math import floor

from django.conf import settings
from django.core.management import call_command
from django.db import migrations
from wagtail_localize.fields import copy_synchronised_fields
from wagtail_localize.synctree import PageIndex

BUCKET_MEANS = [10, 30, 50, 70, 90]


def _get_equivalent_bucket_votes(bucket_votes, bucket_mean, total_creepiness, weighted_bucket_votes_sum):
    if not bucket_votes:
        return []

    bucket_creepiness = bucket_votes * bucket_mean * total_creepiness / weighted_bucket_votes_sum
    bucket_average_creepiness = bucket_creepiness / bucket_votes

    equivalent_votes = [{"count": bucket_votes, "creepiness": floor(bucket_average_creepiness)}]

    equivalent_creepiness = equivalent_votes[0]["count"] * equivalent_votes[0]["creepiness"]

    # Check if there's a residual creepiness (if so, need to correct the equivalent votes)
    if equivalent_creepiness != round(bucket_creepiness):
        residual_creepiness = round(bucket_creepiness) - equivalent_creepiness
        equivalent_votes[0]["count"] -= residual_creepiness
        equivalent_votes.append({"count": residual_creepiness, "creepiness": floor(bucket_average_creepiness) + 1})
        equivalent_creepiness = (
            equivalent_votes[0]["count"] * equivalent_votes[0]["creepiness"]
            + equivalent_votes[1]["count"] * equivalent_votes[1]["creepiness"]
        )

    return equivalent_votes


def _get_equivalent_votes(ProductVote, product):
    equivalent_votes = []
    votes = [int(x) for x in product.votes.vote_bins.split(",")]

    total_creepiness = product.creepiness_value
    weighted_bucket_votes_sum = sum([vote * mean for vote, mean in zip(votes, BUCKET_MEANS)])

    for i, bucket_votes in enumerate(votes):
        equivalent_bucket_votes = _get_equivalent_bucket_votes(
            bucket_votes, BUCKET_MEANS[i], total_creepiness, weighted_bucket_votes_sum
        )
        equivalent_votes.extend(equivalent_bucket_votes)

    equivalent_vote_objects = []
    for vote in equivalent_votes:
        equivalent_vote_objects.extend(
            [ProductVote(value=vote["creepiness"], evaluation=product.evaluation) for _ in range(vote["count"])]
        )

    return equivalent_vote_objects


def _sync_translated_products(products, apps):
    """A migration-compatible copy of `wagtail_localize` sync_locale_trees command."""
    Locale = apps.get_model("wagtailcore", "Locale")
    ProductPage = apps.get_model("wagtailpages", "ProductPage")

    locales = Locale.objects.all().exclude(language_code=settings.LANGUAGE_CODE)

    translated_products = ProductPage.objects.filter(locale__in=locales)

    for product in products:
        for locale in locales:
            target_product = translated_products.get(translation_key=product.translation_key, locale=locale)
            copy_synchronised_fields(product, target_product)
            target_product.save()


def convert_old_votes_to_new_format(apps, schema_editor):
    ProductPage = apps.get_model("wagtailpages", "ProductPage")
    ProductVote = apps.get_model("wagtailpages", "ProductVote")
    ProductPageEvaluation = apps.get_model("wagtailpages", "ProductPageEvaluation")

    default_language = settings.LANGUAGE_CODE

    products = ProductPage.objects.filter(locale__language_code=default_language)

    for product in products:
        evaluation = ProductPageEvaluation.objects.create()
        product.evaluation = evaluation
        product.save()
        product.refresh_from_db()

        equivalent_votes = _get_equivalent_votes(ProductVote, product)

        ProductVote.objects.bulk_create(equivalent_votes)

    _sync_translated_products(products, apps)


class Migration(migrations.Migration):
    dependencies = [
        ("wagtailpages", "0105_add_product_vote_and_evaluation_models"),
    ]

    operations = [
        migrations.RunPython(convert_old_votes_to_new_format, migrations.RunPython.noop),
    ]
