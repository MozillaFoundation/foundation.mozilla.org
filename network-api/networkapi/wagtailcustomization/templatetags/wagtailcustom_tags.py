import re
from django import template
from django.utils.text import slugify
from django.utils.html import strip_tags
from django.utils.safestring import SafeText
from wagtail.core.rich_text import RichText

# We don't actually register any tags: the idea is to tap into
# the richtext filter, but that won't let us change _all_ the
# RichText content, so instead of setting up a filter override,
# we literally reach into the RichText class. And change it.
register = template.Library()

# We'll be wrapping the original RichText.__html__(), so make
# sure we have a reference to it that we can call.
__original__html__ = RichText.__html__

# This matches an h1/.../h6, using a regexp that is only
# guaranteed to work because we know that the source of
# the HTML code we'll be working with generates nice
# and predictable HTML code.
#
# This RE uses three capture groups:
#
# 1. "everything after the h" for the opening tag
# 2. the heading number
# 3. the tag's text content
heading_re = r"<h((\d)[^>]*)>(.+?)</h\2>"


def add_id_attribute(match):
    """
    This is a regexp replacement function that takes
    in the above regex match results, and then turns:

        <h1>some text</h1>

    Into:

        <h1><a class="fragment-id" id="some-text"></a>some text</h1>

    where the id attribute value is generated by running
    the heading text through Django's slugify() function.

    Note that we use a separate fragmentid anchor because this lets
    us control "where the anchor is" independent of the heading,
    allowing us to shift the anchor up while keeping the heading
    in place, to prevent the heading from "disappearing" under
    the sticky navigation element at the top of the page.

    Also note that this replacement will only kick in for h1/h2/h3.
    """
    hsuffix = match.group(1)
    n = match.group(2)
    text_content = match.group(3)
    anchor = ''

    if int(n) < 4:
        id = slugify(strip_tags(text_content))
        anchor = f'<a class="fragment-id" id="{id}"></a>'

    return f'<h{hsuffix}>{anchor}{text_content}</h{n}>'


def with_heading_ids(self):
    """
    We don't actually change how RichText.__html__ works, we just rely
    on the fact that it generates plain text HTML, and wrap it in
    a function that does "whatever it already did", plus a substitution
    pass that adds fragment ids and their associated link elements to
    any headings that might be in the rich text content.
    """
    html = __original__html__(self)

    # While the proxy is written in the assumption that the RichText
    # component's __html__ serializer function generates plain text
    # HTML source code, that assumption might be invalidated at some
    # point in time, so in order to make sure we can safely perform
    # text replacement, we need to verify `html` is an instance of SafeText.
    if type(html) is not SafeText:
        return html

    return re.sub(heading_re, add_id_attribute, html)


# Rebind the RichText's html serialization function such that
# the output is still entirely functional as far as wagtail
# can tell, except with headings enriched with fragment ids.
RichText.__html__ = with_heading_ids
