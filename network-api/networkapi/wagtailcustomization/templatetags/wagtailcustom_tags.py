import re
from django import template
from django.utils.text import slugify
from django.utils.html import strip_tags
from wagtail.core.rich_text import RichText

# We don't actually register any tags: the idea is to tap into
# the richtext filter, but that won't let us change _all_ the
# RichText content, so instead of setting up a filter override,
# we literally reach into the RichText class. And change it.
register = template.Library()

# We'll be wrapping the original RichText.__html__(), so make
# sure we have a reference to it that we can call.
__original__html__ = RichText.__html__

# This matches an h1/.../h6, using a regexp that is only
# guaranteed to work because we know that the source of
# the HTML code we'll be working with generates nice
# and predictable HTML code.
heading_re = r"<h(\d)[^>]*>([^<]*)</h\1>"


def add_id_attribute(match):
    """
    This is a regexp replacement function that takes
    in the above regex match results, and then turns:

        <h1>some text</h1>

    Into:

        <h1><a class="fragment-id" id="some-text"></a>some text</h1>

    where the id attribute value is generated by running
    the heading text through Django's slugify() function.

    This replacement will only kick in for h1/h2/h3.
    """
    n = match.group(1)
    text_content = match.group(2)

    if int(n) > 3:
        return text_content

    id = slugify(strip_tags(text_content))
    return f'<h{n}><a class="fragment-id" id="{id}"></a>{text_content}</h{n}>'


def with_heading_ids(self):
    """
    We don't actually change how RichText.__html__ works, we just rely
    on the fact that it generates plain text HTML, and wrap it in
    a function that does "whatever it already did", plus a substitution
    pass that adds fragment ids and their associated link elements to
    any headings that might be in the rich text content.
    """
    html = __original__html__(self)

    # While the proxy is written in the assumption that the RichText
    # component's __html__ serializer function generates plain text
    # HTML source code, that assumption might be invalidated at some
    # point in time, so in order to make sure we can safely perform
    # text replacement, we need to verify `html` has a string type.
    if type(html) is not str:
        return html

    return re.sub(heading_re, add_id_attribute, html)


# Rebind the RichText's html serialization function such that
# the output is still entirely functional as far as wagtail
# can tell, except with headings enriched with fragment ids.
RichText.__html__ = with_heading_ids
